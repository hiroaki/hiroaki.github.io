<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gserver | What hwat?]]></title>
  <link href="http://hiroaki.github.io/blog/categories/gserver/atom.xml" rel="self"/>
  <link href="http://hiroaki.github.io/"/>
  <updated>2016-03-17T00:30:00+09:00</updated>
  <id>http://hiroaki.github.io/</id>
  <author>
    <name><![CDATA[hiroaki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GServer can exceed the max connections]]></title>
    <link href="http://hiroaki.github.io/blog/2014/1005/gserver-can-exceed-the-max-connections/"/>
    <updated>2014-10-05T22:54:00+09:00</updated>
    <id>http://hiroaki.github.io/blog/2014/1005/gserver-can-exceed-the-max-connections</id>
    <content type="html"><![CDATA[<p>前回 Ruby の <code>gserver</code> のことについて書いた後、少しばかり調べを進めてみていたら、 Ruby 2.2 からは標準添付ではなくなるとの「事実」に遭遇してしまいました。いいライブラリだなと覚えた矢先でしたから、がっかりです。尤も、標準ではなくなるだけのことですから、使い続けることはできるでしょう。</p>

<p>ただ標準添付から外される理由に、（１）テストも無い代物で、（２）ドキュメントどおりには振る舞わず（後述）、（３）だれもメンテナンスしていない状態である、ということが挙げられていて、それがために誰も使っていないから外す、とのことでした。加えてその提案がなされたのが３年前ということもあって、じぶんとしてはまったくモチベーションが下がってしまいました。</p>

<p><a href="https://bugs.ruby-lang.org/issues/5480">Feature #5480: remove GServer from stdlib - ruby-trunk - Ruby Issue Tracking System</a></p>

<!-- more -->


<p></p>

<p>確かに、テストがありませんでした。卵が先か鶏が先か、ゆえにメンテナがいないのも頷けます。そして誰も使っていないかというと、それはどうでしょうか。じぶんにとって、それはどうでもいいことでしたから、特に調べもしませんでしたが、ちょっと検索をかけてみた所では、サンプル以上のことを書いている記事は見つけられませんでした。しかし Ruby で TCP サーバを書く人がどれだけあるかと想像すると、あまりいないんじゃないかという根拠のない──あるとすれば偏見から、思われるので、サーバを書く人がいないから、メンテされるほどの課題が出て来なかったのかも知れない。と、前向きに？考えることにして、動作に問題がないならば、標準であろうがなかろうが、だれが使っていようが、だれも使っていなかろうが、便利ならば使えばいいのだという結論に至ります。</p>

<p>そのコードは、 Perl ばかり書いて来たじぶんにとって馴染みの薄いスレッドを使っている所が特徴的なわりにすっきりしていてじつにシンプルです。みんなこれを使えばいいのにと、改めて思います。そうして使う人が増えれば、メンテナンスするひとも出てくることも期待できるでしょう。</p>

<p>じぶんはある実務で SMTP サーバを書く必要が生じて、 <code>midi-smtp-server</code> という gem を選択して使い始めたのが <code>gserver</code> を知る切っ掛けでもあったのですが、いまのところ上手くいっています。インターネットに出ない閉じたネットワーク内で使う代物なので、細かい気遣いをすることはなかったのですが、いざというときに内部動作が理解しやすいことも、ライブラリの選択にあたっては重視していましたから、その内容がシンプルであることは心理面でも助けになりました。</p>

<p>さて、そんな経緯もありながらしばらく <code>gserver</code> を扱っているのですが、自作の SMTP サーバのテストを書いている時に、最大コネクション数が設定値を超えてしまう現象に遭遇しました。それも再現性がなく、ときどきです。</p>

<p>冒頭の、標準添付から外される理由の（２）として挙げられているのは、このことかなと思いました。</p>

<p>ソースに当たってみると、最大コネクション数の管理とスレッドが連動しているところなど、なるほどこういうもんなんだなと鵜呑みにしてしまっていましたが、よくよく見ていると、クライアントの接続要求に応じて生成された子スレッドの中で現在の接続数を増やしているので、その処理が通るのが先か、または親スレッドが新たに接続要求に応じて現在の接続数をチェックするのが先かで、結果が違ってくるんじゃないかと思えて来ました。</p>

<p>そこで、ものは試しに、修正を加えてみることにしました。</p>

<p><a href="https://github.com/hiroaki/gserver/tree/tight-max-connection-limitation">hiroaki/gserver at tight-max-connection-limitation</a></p>

<p>rspec を追加したコミットを先にして、修正前のオリジナルを試験してみますと、じぶんの手元のマシンでは 100 回試行すればそのうち数回は設定した最大接続数を超えた接続が行われ、テストが失敗しました。そして、追加の修正コミットのあとは、試行回数 1,000 にしても、最大接続数を超えることはなくなり、テストは成功ました。うまくいったようです。これもライブラリの内部がシンプルな構造であったためにできたことかもしれません。（ここで、できた、というのは、手を入れてみようと思うことができた、というところにかかっています。）</p>

<p>ただし、パッチした影響で、ほかの機能の安全が守られているかどうかというのが判らないのが、不安の残る所です。こういうときに、テストがもともと無いのには、確かに困ります。現在のバージョンにテストがないということは、そのこと自体が将来の発展を妨げる一因となっていると、いえる事例かもしれません。</p>

<p>ところでこのブランチ、フォーク元にプル・リクエストを出してみようかとも考えましたが、少なくとも誰かにレビューしてもらってからのほうがいいかと思って躊躇っていました。でもメンテされていないものにマージしてほしいとは言えません。 <code>gserver</code> は標準添付ということで心強く思ってたのですが、これまで述べて来たようにもともと頼りないライブラリだったとあれば、このままお蔵入りにするか、プライベートで使うだけの代物になるだろうと思います。しばらくは実務で使ってる実装の方でも、オリジナルの動向の方でも、様子を見守るスタンス、です。</p>

<p>──見守るとは言いますが、 SMTP サーバを書くにあたって代わりになる、かつメンテナンスされているものがあれば、それを使って行きたいというのが本音ですけれども。みなさんは SMTP サーバを書く時に、どんなライブラリを使っているのでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to shutdown GServer gracefully?]]></title>
    <link href="http://hiroaki.github.io/blog/2014/0907/how-to-shutdown-gserver-gracefully/"/>
    <updated>2014-09-07T21:34:00+09:00</updated>
    <id>http://hiroaki.github.io/blog/2014/0907/how-to-shutdown-gserver-gracefully</id>
    <content type="html"><![CDATA[<p>Ruby の標準添付ライブラリに <a href="http://docs.ruby-lang.org/ja/2.1.0/library/gserver.html">gserver</a> というのがあって、これを用いれば頗る簡単に TCP サーバを書くことが出来、こりゃいいね、って思いながら使ってみたのですけれども、サーバの停止の手続きについてちょっと悩むことがありました。</p>

<p>いざサーバの停止を行おうとするとき、まだ接続中のクライアントが居たらば、その終了を待ってから、サーバは停止してほしいのは誰しも考える所です（「優雅なシャットダウン」 &ldquo;Graceful shutdown&rdquo; ）。<code>GServer</code> クラスのインタフェースとしては <code>#shutdown</code> メソッドが、それらしいことを行うはずなのですが、実際はそう上手くは問屋が卸しませんでした。</p>

<!-- more -->


<p>承前の通り簡単な内容なのでまずは書いたコード全容を貼ります。処理内容はいわゆる echo サーバです。このサーバを（フォアグラウンドで）起動したら、 <code>Ctrl+c</code> （ INT シグナル）で、優雅なシャットダウンをさせようとしています。ちなみにクライアントは、サーバに空行を送ることで接続を終了します。</p>

<pre><code>require 'gserver'

class EchoServer &lt; GServer

  def initialize(port=10001, host='127.0.0.1', *args)
    super(port, host, *args)
    self.audit = true
    trap :INT, proc {
      self.shutdown
    }
  end

  def serve(io)
    loop do
      if IO.select([io], nil, nil, 0.1)
        data = io.gets
        break if data.nil? || data =~ /^[\r\n]*$/
        io.puts("echo: #{data}")
      end
    end
    io.close
  end

end

STDERR.sync
STDOUT.sync
server = EchoServer.new
server.start
server.join
</code></pre>

<p>いざこれを実行し、別端末からクライアントとして接続します。 echo の動作はうまくいきます。空行を送ることでいったん接続を切り、改めて、今度はクライアントを接続中にしたまま、サーバに INT シグナルを送ってみます。クライアントが接続中なので、まだ終了しません。思惑どおりです。</p>

<p>しかし、そのクライアントを切断させますと、どうでしょうか。サーバの動作ログにはクライアントが切断した旨が出力されますが、サーバは止まりません。おや？　と思いました。また、この状態で、再びクライアントから接続を試みると、繋がってしまいます。これもおや？　と思いました。サーバはまだ接続を受け付けてしまっていますから、忙しいサイトでは休む間もないことでしょう。いちおう、すべてのクライアントが接続を終了させると、サーバも終了しましたが。</p>

<p>何がいけないのでしょうか？</p>

<p><code>GServer</code> クラスのソースにあたってみると、 <code>#sutdown</code> メソッドはたんにフラグを立てるだけの様で、実際の停止の手続きは別にありました。サーバのメインの処理は、新たなクライアントの接続を待つ無限ループです。無限ループは、フラグが立っていることで抜け、そして終了の手続きへと進む、といった風に読めます。サーバがループの中で、 ACCEPT 状態、つまり新たなクライアントの接続を待っている間は、文字通りその地点で待っているので、フラグをチェックする所へ来ないのです。事実、気がつけば rdoc での <code>#shutdown</code> の説明には &ldquo;Schedule a shutdown for the server&rdquo; と書いてありました。まさしく。端的に表していますが、ではどうしたら、優雅なシャットダウンを実現できるでしょうか。</p>

<p>このからくりからひとつ思いつく解決方法は、 <code>#sutdown</code> メソッドを実行したで、新たなクライアントを作り、接続し、そして切断することです。</p>

<pre><code>    trap :INT, proc {
      self.shutdown
      TCPSocket.open(host,port).close
    }
</code></pre>

<p>こうすることで、新たな接続を受け付けたサーバは、ループを一回進め、次のループへのチェックへ制御がやってきます。すると事前の <code>#shutdown</code> メソッドによりフラグが立っているので、ループを抜け、サーバのスレッドは子スレッドの終了を迎える体制に入ります。また同時に、このときは既にサーバは ACCEPT をしていない状態ですから、クライアントからの新しい接続は、期待どおり拒否されることになります。</p>

<p>そこまで行けば、あとは接続中の幾つかのクライアント（子スレッド）がそれぞれ自身の処理を終えて接続を切り次第 <code>server.join</code> のところに集まってくるのを待っているだけです。そうしてすべての子スレッドが集まることでサーバも目出たく、優雅に、終了することが出来ます。</p>

<p>実際にやってみますと、思いどおりにいきました。しかしいまひとつ、釈然としません。なにか方法はないものかと、もう少し探ってみることにしました。</p>

<p><code>GServer</code> のソースをじっと見つめていると、 <code>#start</code> メソッドによって内部で生成される <code>TCPServer</code> のインスタンス（サーバ・スレッド）が <code>#accept</code> メソッドでクライアントの接続を待っています。このメソッドはスレッドの流れをブロックします。</p>

<p>ここがポイントであることには間違いないので、このブロック状態を解く手だてがあればよさそうなのですが、そのような使命を直接的に背負った機能は、どの API にも見つけられませんでした。その理由を知るには、そもそも TCP 的にどのようにそれを実行するのか（するべきなのか）についてまず知らないといけないと考え、それから関係各所を回ってみたのですが（ via Google ）、しかしじぶんが開いたそれらしい様々などのドキュメントにも ACCEPT 状態を無理矢理？解く方法は明示されていませんでした（明示されていることを見つけられませんでした）。</p>

<p>そんな中で、試しに、無理矢理サーバのソケットを閉じてはどうだろうと思い至ります。 <code>GServer</code> のインスタンスの中にサーバソケットを持っている <code>TCPServer</code> のインスタンスがあるので、それを摑み取って <code>#close</code> を送ってみることにしました。いうなれば、間接的に ACCEPT 状態のブロックを解くことを期待する魂胆です。</p>

<pre><code>    trap :INT, proc {
      self.shutdown
      self.instance_variable_get(:@tcpServer).close
    }
</code></pre>

<p>この方法はどうやら上手くいったようです。 INT シグナルを trap したサーバは、 ACCEPT をやめたと見えて、新しいクライアントを受け付けなくなりました。一方で、接続中のクライアントが既にあった場合は、そのコネクションが切られるまで、待っていました。そして、すべてのクライアントが接続を終了したとき、はじめてサーバも終了しました。いい案配です。</p>

<p>さて、こうしてみると、 <code>Gserver#shutdown</code> の後に、クライアント接続を一回虚しく空振りさせるよりも、 <code>TCPServer#close</code> を発行する方がスマートなように思えます。ただし、それが正攻法ならば。──言うまでもなくこれはアクセス手段が意図的に公開されていないインスタンスを摑み取っている時点で正攻法ではありません。そして一方 <code>TCPServer#close</code> も確信があってやっていることではないので、これでいいのかと不安は残ります。そのような不安を抱えてまでも <code>TCPServer#close</code> するメリットは、虚しいかなあまりないようです。従って、理屈的に正攻法である空振りクライアントを実装するほうが、不格好でも、良いものだと判断するほかありません。とはいえ、いちおう、一定の成果は得られた気がします。──顛末はここまでです。</p>

<p>結局のところ、優雅なシャットダウンのために、空振りクライアント接続をするといったいまひとつ優雅ではない実装を行う、ということでじぶんの悩みはそこに落とさざるを得なかったという話は終わりなのですが、さてしかし、今回の主役であるその <code>GServer</code> クラスのほう、こちらこのへんの動きは（優雅なシャットダウンは新たなクライアントが接続しに来ないと始まらないこと）
、そもそも設計の想定のうちなのでしょうか。──必然的に湧いて来るこの次なる疑問については、でも、またの機会にしたいと思います。長くなりました。</p>

<p>追記：その後、こんなチケットを見つけました。同じことを言っているのでしょうか？　ただ、それから二年以上動きがないようです。さて。</p>

<p><a href="https://bugs.ruby-lang.org/issues/6369">Bug #6369: GServer blocking after shutdown called - ruby-trunk - Ruby Issue Tracking System</a></p>
]]></content>
  </entry>
  
</feed>
